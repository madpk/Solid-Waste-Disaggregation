text(cca_model, display = "sites", labels = env_data$Plots, col = "black", cex = 0.7)
# Add species and environmental labels
text(cca_model, display = "species", col = "brown", cex = 0.7)
text(cca_model, display = "bp", col = "darkblue", cex = 0.8)
# Assuming 'group' contains Invaded/Uninvaded info
group <- ifelse(grepl("Invaded", env_data$Plots), "Invaded", "Uninvaded")
colors <- ifelse(group == "Invaded", "red", "blue")
# Base plot with scaling
plot(cca_model, type = "n", scaling = 2)
# Add sites with group colors
points(cca_model, display = "sites", pch = 21, col = "black", bg = colors, scaling = 2)
# Add site labels
text(cca_model, display = "sites", labels = env_data$Plots, cex = 0.7, scaling = 2)
# Add species names
text(cca_model, display = "species", col = "darkred", cex = 0.7, scaling = 2)
# Add environmental vectors
text(cca_model, display = "bp", col = "darkblue", cex = 0.8, scaling = 2)
# Optional: Add legend
legend("topright", legend = c("Invaded", "Uninvaded"), pt.bg = c("red", "blue"), pch = 21)
# Add site points with group-specific colors
points(cca_model, display = "sites", pch = 21, col = "black", bg = colors)
# Add site labels (optional)
text(cca_model, display = "sites", labels = env_data$Plots, col = "black", cex = 0.7)
# Add species and environmental labels
text(cca_model, display = "species", col = "brown", cex = 0.7)
text(cca_model, display = "bp", col = "darkblue", cex = 0.8)
legend("topright", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 21)
cca_model <- cca(species_data ~ ., data = env_data)
summary(cca_model)
plot(cca_model)
group <- ifelse(grepl("Invaded", PCA_data$Plots), "Invaded", "Uninvaded")
colors <- ifelse(group == "Invaded", "orange", "darkgreen")
plot(cca_model, type = "n")
# Add site points with group-specific colors
points(cca_model, display = "sites", pch = 21, col = "black", bg = colors)
# Add site labels (optional)
text(cca_model, display = "sites", labels = env_data$Plots, col = "black", cex = 0.7)
# Add species and environmental labels
text(cca_model, display = "species", col = "brown", cex = 0.7)
text(cca_model, display = "bp", col = "darkblue", cex = 0.8)
legend("topright", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 21)
legend("bottomright", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 21)
legend("bottoleft", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 21)
plot(cca_model, type = "n")
# Add site points with group-specific colors
points(cca_model, display = "sites", pch = 21, col = "black", bg = colors)
# Add site labels (optional)
text(cca_model, display = "sites", labels = env_data$Plots, col = "black", cex = 0.7)
# Add species and environmental labels
text(cca_model, display = "species", col = "brown", cex = 0.7)
text(cca_model, display = "bp", col = "darkblue", cex = 0.8)
legend("bottomleft", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 21)
legend("bottomleft", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 10)
legend("bottomleft", legend = c("Invaded", "Uninvaded"), pt.bg = c("orange", "darkgreen"), pch = 21)
View(PCA_data)
cca_model
cca_model <- cca(species_data ~ ., data = env_data, scale=2)
summary(cca_model)
plot(cca_model)
# Load libraries
library(ggplot2)
library(dplyr)
library(tidyr)
# Create your data manually (based on the image you provided)
invaded <- data.frame(
Plot = paste0("Invaded ", 1:10),
Density = c(133, 211, 189, 222, 178, 222, 233, 200, 189, 189),
BA = c(5.7, 8.22, 24.48, 7.33, 7.24, 10.64, 12.92, 17.19, 8.18, 10.42),
Richness = c(5, 7, 7, 6, 11, 6, 5, 3, 7, 7),
AGB = c(19.8, 28.63, 119.45, 32.33, 29.45, 43.7, 48.15, 81.69, 33.54, 40.71),
Group = "Invaded"
)
uninvaded <- data.frame(
Plot = paste0("Uninvaded ", 1:10),
Density = c(411, 356, 378, 367, 189, 389, 567, 433, 367, 400),
BA = c(7.11, 7.29, 6.65, 4.76, 2.94, 6.19, 7.38, 7.16, 4.03, 3.93),
Richness = c(15, 14, 9, 10, 7, 11, 13, 11, 9, 13),
AGB = c(18.93, 17.89, 14.24, 11.11, 8.01, 16.49, 17.44, 23.65, 10.72, 9.56),
Group = "Uninvaded"
)
# Combine both
combined_data <- rbind(invaded, uninvaded)
# Pivot longer for ggplot
long_data <- pivot_longer(combined_data,
cols = c(Density, BA, Richness, AGB),
names_to = "Variable",
values_to = "Value")
# Plot
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal()
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal()
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.4)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 4, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 3, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2.5, alpha = 0.7) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2.5, alpha = 0.8) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2.5, alpha = 0.6) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.5, size = 2.5, alpha = 0.6) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Plot with red and green colors
ggplot(long_data, aes(x = Group, y = Value, color = Group)) +
geom_jitter(width = 0.2, size = 2.5, alpha = 0.6) +
scale_color_manual(values = c("Invaded" = "darkred", "Uninvaded" = "darkgreen")) +
facet_wrap(~Variable, scales = "free_y") +
labs(title = "Jittered Plots for Invaded vs Uninvaded Plots",
y = "Value", x = "Plot Type") +
theme_minimal() +
theme(
panel.border = element_rect(color = "grey", fill = NA, linewidth = 0.2)
)
# Load Kerala LSGI Multipolygon
kerala_admin <- st_read("Kerala_admin_multipolygon.geojson")
# ------------------------------------------------------------------------------
# Automated Machine Learning-Based Spatial Disaggregation Framework
# Author: Madhuraj Palat Kannakai
# GitHub: https://github.com/madpk
# ------------------------------------------------------------------------------
# Set Working Directory
wd<-setwd("C:/Users/madhu/OneDrive/Desktop/WD")
# Load Required Libraries
library(tidyverse)    # Data manipulation and ggplot2
library(sf)           # Spatial data handling
library(terra)        # Raster and spatial data processing
library(exactextractr)# Efficient raster extraction
library(h2o)          # Automated Machine Learning
library(FactoMineR)   # Principal Component Analysis
library(factoextra)   # PCA Visualization
library(corrplot)     # Correlation matrix visualization
# Load Kerala LSGI Multipolygon
kerala_admin <- st_read("Kerala_admin_multipolygon.geojson")
# Reproject to UTM Zone 43N (EPSG:32643)
kerala_admin <- st_transform(kerala_admin, crs = 32643)
# ------------------------------------------------------------------------------
# Automated Machine Learning-Based Spatial Disaggregation Framework
# Author: Madhuraj Palat Kannakai
# GitHub: https://github.com/madpk
# ------------------------------------------------------------------------------
# Set Working Directory
wd<-setwd("C:/Users/madhu/OneDrive/Documents/GitHub/-Solid-Waste-Disaggregation
/Datasets")
# ------------------------------------------------------------------------------
# Automated Machine Learning-Based Spatial Disaggregation Framework
# Author: Madhuraj Palat Kannakai
# GitHub: https://github.com/madpk
# ------------------------------------------------------------------------------
# Set Working Directory
wd<-setwd("C:/Users/madhu/OneDrive/Documents/GitHub/-Solid-Waste-Disaggregation/Datasets")
# Load Required Libraries
library(tidyverse)    # Data manipulation and ggplot2
library(sf)           # Spatial data handling
library(terra)        # Raster and spatial data processing
library(exactextractr)# Efficient raster extraction
library(h2o)          # Automated Machine Learning
library(FactoMineR)   # Principal Component Analysis
library(factoextra)   # PCA Visualization
library(corrplot)     # Correlation matrix visualization
# Load Kerala LSGI Multipolygon
kerala_admin <- st_read("Kerala_admin_multipolygon.geojson")
# Reproject to UTM Zone 43N (EPSG:32643)
kerala_admin <- st_transform(kerala_admin, crs = 32643)
# List all .tif raster files in the working directory
raster_files <- list.files(wd, pattern = "\\.tif$", full.names = TRUE)
# Load all rasters as SpatRaster objects using terra::rast()
rasters <- lapply(raster_files, rast)
# Set the first raster as the reference for resampling and extent alignment
reference_raster <- rasters[[1]]
# Resample rasters 2 and 3 to match the reference raster's resolution and extent
rasters[[2]] <- resample(rasters[[2]], reference_raster, method = "bilinear")
rasters[[3]] <- resample(rasters[[3]], reference_raster, method = "bilinear")
# Define common extent from the reference raster
common_extent <- ext(reference_raster)
# Align all rasters to the common extent
aligned_rasters <- lapply(rasters, function(r) extend(r, common_extent))
# Stack all aligned & convert to a list
raster_aligned <- rast(aligned_rasters)
raster_items<-as.list(raster_aligned)
# Create a vector containing the names of raster layers
raster_names <- c("building_fractional_count_100m_2023",
"built_volume_nonresidential_100m_2020",
"built_volume_residential_100m_2020",
"Population_Dens_2020_Kerala_100m")
# Assign names to raster layers
names(raster_items) <- raster_names
# Define the extraction function (sum of raster values within each LSGI)
extract_raster_sum <- function(raster, lsgi_vect) {
exact_extract(raster, lsgi_vect, 'sum')
}
# Apply the extraction function to each raster in the list
lsgi_data_sum <- map(raster_items, ~extract_raster_sum(.x, kerala_admin))
# Assign descriptive names to the extracted data
names(lsgi_data_sum) <- c("builtcount_sum",
"builtvolnres_sum",
"builtvolres_sum",
"popdens_sum")
# Combine extracted values with original spatial data
lsgi_data_sum_comb <- bind_cols(as.data.frame(lsgi_data_sum), kerala_admin)
# ------------------------------------------------------------------------------
# Automated Machine Learning-Based Spatial Disaggregation Framework
# Author: Madhuraj Palat Kannakai
# GitHub: https://github.com/madpk
# ------------------------------------------------------------------------------
# Set Working Directory
wd<-setwd("C:/Users/madhu/OneDrive/Documents/GitHub/-Solid-Waste-Disaggregation/Datasets")
# Load Required Libraries
library(tidyverse)    # Data manipulation and ggplot2
library(sf)           # Spatial data handling
library(terra)        # Raster and spatial data processing
library(exactextractr)# Efficient raster extraction
library(h2o)          # Automated Machine Learning
library(FactoMineR)   # Principal Component Analysis
library(factoextra)   # PCA Visualization
library(corrplot)     # Correlation matrix visualization
# Load Kerala admin Multipolygon
kerala_admin <- st_read("Kerala_admin_multipolygon.geojson")
# Reproject to UTM Zone 43N (EPSG:32643)
kerala_admin <- st_transform(kerala_admin, crs = 32643)
# List all .tif raster files in the working directory
raster_files <- list.files(wd, pattern = "\\.tif$", full.names = TRUE)
# Load all rasters as SpatRaster objects using terra::rast()
rasters <- lapply(raster_files, rast)
# Set the first raster as the reference for resampling and extent alignment
reference_raster <- rasters[[1]]
# Resample rasters 2 and 3 to match the reference raster's resolution and extent
rasters[[2]] <- resample(rasters[[2]], reference_raster, method = "bilinear")
rasters[[3]] <- resample(rasters[[3]], reference_raster, method = "bilinear")
# Define common extent from the reference raster
common_extent <- ext(reference_raster)
# Align all rasters to the common extent
aligned_rasters <- lapply(rasters, function(r) extend(r, common_extent))
# Stack all aligned & convert to a list
raster_aligned <- rast(aligned_rasters)
raster_items<-as.list(raster_aligned)
# Create a vector containing the names of raster layers
raster_names <- c("building_fractional_count_100m_2023",
"built_volume_nonresidential_100m_2020",
"built_volume_residential_100m_2020",
"Population_Dens_2020_Kerala_100m")
# Assign names to raster layers
names(raster_items) <- raster_names
# Define the extraction function (sum of raster values within each admin)
extract_raster_sum <- function(raster, admin_vect) {
exact_extract(raster, admin_vect, 'sum')
}
# Apply the extraction function to each raster in the list
admin_data_sum <- map(raster_items, ~extract_raster_sum(.x, kerala_admin))
# Assign descriptive names to the extracted data
names(admin_data_sum) <- c("builtcount_sum",
"builtvolnres_sum",
"builtvolres_sum",
"popdens_sum")
# Combine extracted values with original spatial data
admin_data_sum_comb <- bind_cols(as.data.frame(admin_data_sum), kerala_admin)
# Create a Machine Learning-ready dataframe (remove geometry, retain only values)
admin_data_summl <- admin_data_sum_comb %>%
st_drop_geometry() %>%
select(builtcount_sum, builtvolnres_sum, builtvolres_sum, popdens_sum, SW_Ton)
# Preview the final ML-ready dataframe
glimpse(admin_data_summl)
# Combine ML features with admin labels
pca_data <- data.frame(admin_data_summl, admin = factor(admin_data_sum_comb$admin))
# Rename columns for clarity in visualizations
colnames(pca_data) <- c("Building count",
"NRESBU volume",
"RESBU volume",
"Population density",
"Solid waste generation",
"admin")
pca_result <- PCA(pca_data[1:5], graph = FALSE)  # Only numeric variables
# Combine ML features with admin labels
pca_data <- data.frame(admin_data_summl, admin = factor(admin_data_sum_comb$admin))
admin_data_summl
pca_data
# Combine ML features with admin labels
pca_data <- data.frame(admin_data_summl, admin = factor(admin_data_sum_comb$LSGI))
# Rename columns for clarity in visualizations
colnames(pca_data) <- c("Building count",
"NRESBU volume",
"RESBU volume",
"Population density",
"Solid waste generation",
"admin")
pca_result <- PCA(pca_data[1:5], graph = FALSE)  # Only numeric variables
# PCA Biplot
fviz_pca_biplot(pca_result,
col.ind = pca_data$admin,
palette = "lancet",
shape.ind = 16,
pointshape = 16,
pointsize = 4,
alpha.ind = 0.8,
addEllipses = FALSE,
repel = TRUE,
label = "var",
mean.point = FALSE,
legend.title = "admin")
# Compute Spearman correlation matrix
spearman_corr <- cor(pca_data[, 1:5], method = "spearman")
# Display correlation matrix with numbers
corrplot(spearman_corr,
method = "number",
number.cex = 0.8)
# Initialize H2O cluster (skip if already initialized)
h2o.init()
# Load the AutoML model used in the study
aml <- h2o.loadModel("V3_DeepLearning_grid_3")
# View the model's parameters
aml_model_params <- aml@parameters
# Get variable importance (only for models that support it, like XGBoost, GBM)
var_imp <- h2o.varimp(aml )
# Create the variable importance data frame
var_imp <- data.frame(
variable = c("Building Count", "Population Density", "RESBU Volume",
"NRESBU Volume"),
percentage = c(0.335697, 0.261192, 0.275932, 0.127179) * 100  # Convert to %
)
# Plot the variable importance
ggplot(var_imp, aes(x = reorder(variable, percentage), y = percentage)) +
geom_bar(stat = "identity", fill = "#69b3a2", color = "black", width = 0.6) +
coord_flip() +
labs(
x = "Variable",
y = "Importance (%)",
title = "Relative Variable Importance"
) +
geom_text(
aes(label = sprintf("%.1f%%", percentage)),
hjust = -0.2,
size = 5,
fontface = "bold"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.text = element_text(size = 12),
axis.title = element_text(size = 14, face = "bold"),
panel.grid.major.y = element_blank(),  # Optional: cleaner look
panel.grid.minor = element_blank()
) +
ylim(0, max(var_imp$percentage) + 10)  # Add space for labels above bars
# Convert the polygon to 'terra' format and split into individual admins
multipolygon <- vect(kerala_admin)
multipolygon_list <- split(multipolygon, seq(nrow(multipolygon)))
# Convert raster stack into a list
stacked_rasters <- as.list(raster_items)
# Function to crop and mask raster with a polygon
crop_rast <- function(input_raster, multipolygon) {
cropped <- terra::crop(input_raster, multipolygon)
masked <- terra::mask(cropped, multipolygon)
}
# Function to normalize raster using min-max scaling
normalize_raster <- function(raster_layer) {
min_val <- global(raster_layer, "min", na.rm = TRUE)[1, 1]
max_val <- global(raster_layer, "max", na.rm = TRUE)[1, 1]
(raster_layer - min_val) / (max_val - min_val)
}
# Crop, mask, and normalize all raster layers for each polygon
cropped_normalized_rasters <- map(multipolygon_list, function(polygon) {
map(stacked_rasters, ~ {
cropped <- crop_rast(.x, polygon)
normalize_raster(cropped)
})
})
# Define variable weights based on variable importance (must match order)
weights <- c(0.335697, 0.127179, 0.275932, 0.261192)
# Apply weights to each normalized raster layer
weighted_rasters <- map(cropped_normalized_rasters, function(raster_list) {
map2(raster_list, weights, function(raster, weight) {
raster * weight
})
})
# Sum weighted rasters to create composite raster for each admin
sum_rasters <- map(weighted_rasters, function(raster_list) {
rast(raster_list) %>% app(sum, na.rm = TRUE)
})
# Scale raster so that each admin raster sums to 1 (i.e., total weight = 1)
scale_to_sum_one <- function(raster) {
total_sum <- sum(values(raster), na.rm = TRUE)
raster / total_sum
}
scaled_rasters <- map(sum_rasters, scale_to_sum_one)
# Disaggregate solid waste (SW_Ton) into the raster cells using scaled weights
disaggregated_waste_rasters <- map2(kerala_admin$SW_Ton, scaled_rasters,
function(total_waste, raster) {
raster * total_waste
})
# Combine all admin rasters into a single raster layer
raster_collection <- sprc(disaggregated_waste_rasters)
merged_raster <- merge(raster_collection)
plot(merged_raster)
